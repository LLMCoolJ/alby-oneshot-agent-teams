# Lightning Wallet Demo

A React application demonstrating 8 Bitcoin Lightning Network payment scenarios using the [Alby SDK](https://github.com/getAlby/alby-js-sdk). Built entirely by Claude Code agent teams following a spec-driven workflow.

**Live demo wallets:** [faucet.nwc.dev](https://faucet.nwc.dev) (no setup required)

## Rebuild From Scratch

This repo includes a `START-HERE` git tag that marks the point before any code was generated. Everything after it was built by Claude Code agent teams. To rebuild the entire application yourself:

### 1. Clone and reset to the starting point

```bash
git clone <repo-url>
cd <repo>
git checkout -b my-build START-HERE
```

This gives you a clean working tree with only the specs, skills, and prompts — no generated code.

### 2. Configure `CLAUDE_CODE_TMPDIR`

Update `.claude/settings.json` and `.claude/settings.local.json` with your actual project path:

```jsonc
// .claude/settings.json and .claude/settings.local.json
{
  "CLAUDE_CODE_TMPDIR": "/path/to/your/clone",
  "env": {
    "CLAUDE_CODE_TMPDIR": "/path/to/your/clone",
    // ...
  }
}
```

Optionally set it in your shell profile:

```bash
# ~/.bashrc or ~/.zshrc
export CLAUDE_CODE_TMPDIR="/path/to/your/clone"
```

### 3. Enable agent teams

The settings files include `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS: true`, which is required for the multi-agent `/implement-spec` workflow. This is already set in the checked-in config — just make sure you don't remove it.

### 4. Generate the PREAMBLE

Open Claude Code in the project directory and run:

```
/implement-spec init
```

This spawns parallel sub-agents to extract structured data from every spec and generates `specs/PREAMBLE.md` — the context document that every agent receives during implementation. **This step is required before implementing any specs.**

### 5. Run the build

You have two options:

**Option A: Build specs one at a time**

```
/implement-spec 01
/implement-spec 02
/implement-spec 03
...
```

This lets you inspect results between specs, make adjustments, or restart from a specific point. Specs must be built in order (each depends on earlier ones).

**Option B: Build all specs at once**

```
@IMPLEMENT.md
```

This triggers the full sequential build of all 15 specs. Each spec is implemented, tested, reviewed, and committed automatically by a 3-agent team (builder, tester, reviewer) via the `/implement-spec` skill.

In either case, if context is lost mid-spec, just re-run `/implement-spec NN` — the manifest at `progress/spec-NN/manifest.json` tracks phase-level state, so it picks up exactly where it left off.

---

## Table of Contents

- [Rebuild From Scratch](#rebuild-from-scratch)
- [How This Repo Was Built](#how-this-repo-was-built)
  - [Starting Point](#starting-point)
  - [Step 1: Write the PRD](#step-1-write-the-prd)
  - [Step 2: Generate Specs from the PRD](#step-2-generate-specs-from-the-prd)
  - [Step 3: Align Specs with ALIGN_SPEC_PROMPT.md](#step-3-align-specs-with-align_spec_promptmd)
  - [Step 4: Generate PREAMBLE.md](#step-4-generate-preamblemd)
  - [Step 5: Implement All Specs](#step-5-implement-all-specs)
- [The IMPLEMENT.md Numbering Bug](#the-implementmd-numbering-bug)
- [When Agent Teams Broke Down](#when-agent-teams-broke-down)
- [What is MEMORY.md?](#what-is-memorymd)
- [The Alby Agent Skill](#the-alby-agent-skill)
- [The Generated Application](#the-generated-application)
  - [Architecture](#architecture)
  - [The 8 Scenarios](#the-8-scenarios)
  - [Tech Stack](#tech-stack)
  - [Project Structure](#project-structure)
- [Running the Application](#running-the-application)
- [Testing](#testing)
- [Build Pipeline Summary](#build-pipeline-summary)

---

## How This Repo Was Built

This entire application was generated by Claude Code using a multi-phase workflow. The repo includes a `START-HERE` git tag that marks the starting point — everything before it is scaffolding (the specs, skills, and prompts); everything after it is generated code.

### Starting Point

At the `START-HERE` tag, the repo contained:

- `PRD.md` — the product requirements document
- `specs/` — 17 specification files (00-overview through 16-testing-strategy)
- `specs/ALIGNMENT_TRACKER.md` — tracking cross-spec consistency
- `ALIGN_SPEC_PROMPT.md` — the prompt used to align specs
- `IMPLEMENT.md` — the orchestration prompt for implementing all specs
- `.claude/skills/implement-spec/` — the skill definition for implementing a single spec
- `.claude/skills/alby-agent-skill/` — Lightning/NWC documentation skill
- `progress/` — empty manifest directories for tracking implementation phases

No application code existed yet. The 35 commits after `START-HERE` are all generated.

### Step 1: Write the PRD

The process starts with `PRD.md`, a product requirements document describing:

- 8 "Alice & Bob" Lightning payment scenarios
- The tech stack (React, TypeScript, Vite, Tailwind, Express, Alby SDK)
- UI component descriptions (sidebar, wallet cards, transaction log)
- SDK method signatures for each scenario
- Testnet setup instructions

The PRD was written manually to define what the application should do.

### Step 2: Generate Specs from the PRD

The PRD was broken into 17 implementation specs in the `specs/` directory:

| # | Spec | Purpose |
|---|------|---------|
| 00 | overview | Architecture reference (no code) |
| 01 | project-setup | Vite, TypeScript, Tailwind config |
| 02 | process-management | Systemd services, dev scripts |
| 03 | shared-types | TypeScript types, constants, type guards |
| 04 | shared-components | UI primitives (Button, Card, Badge, etc.) |
| 05 | wallet-context | React Context, hooks, wallet components |
| 06 | layout | App shell, sidebar, routing |
| 07-14 | scenarios 1-8 | Each payment scenario page |
| 15 | backend | Express API server |
| 16 | testing-strategy | Test infrastructure, mocks, CI |

Each spec defines exactly what files to create, what they export, what tests to write, and what dependencies they have on earlier specs. Specs are ordered so each one only imports from specs with a lower number.

### Step 3: Align Specs with ALIGN_SPEC_PROMPT.md

Before implementation, specs were cross-checked for consistency using `ALIGN_SPEC_PROMPT.md`. This prompt:

1. Reads all reference specs (types, components, hooks, layout, backend)
2. Reads the target scenario spec
3. Checks for inconsistencies: type names, component props, hook signatures, route paths, file structure patterns
4. Fixes inconsistencies (preferring to fix the scenario spec over the reference)
5. Tracks progress in `specs/ALIGNMENT_TRACKER.md`

The alignment prompt is run repeatedly. Each run processes one spec, updating its status from `pending` → `fixing` → `no fixes`. The process uses the `/alby-agent-skill` to verify SDK method signatures are correct.

**To re-run alignment:**

1. Set any spec status to `pending` in `specs/ALIGNMENT_TRACKER.md`
2. Run the prompt from `ALIGN_SPEC_PROMPT.md` in Claude Code
3. Repeat until all specs show `no fixes`

### Step 4: Generate PREAMBLE.md

Before implementation can begin, the system needs a context document that summarizes all specs for the agent workers. This is generated with:

```
/implement-spec init
```

This spawns parallel sub-agents (one per spec) that extract structured data: file lists, exports, routes, coding standards, mock patterns, and test commands. The results are merged into `specs/PREAMBLE.md`, which contains:

- Tech stack summary
- Reference file tables (what each spec creates)
- Scenario route tables
- Import availability rules (spec N can only import from specs < N)
- 43 coding standards extracted from all specs
- Test command reference
- Mock patterns for NWC, Lightning Tools, and hooks

Every agent worker receives PREAMBLE.md as its first context, ensuring consistent implementation across all specs.

### Step 5: Implement All Specs

Implementation is orchestrated by `IMPLEMENT.md`, which runs `/implement-spec NN` for each spec in sequence. Each spec goes through a 10-phase workflow managed by a 3-agent team:

| Phase | Agent | Task |
|-------|-------|------|
| 1 | Builder | Implement the spec's code |
| 2 | Reviewer | Verify implementation matches spec |
| 3 | Tester | Write unit tests |
| 4 | Tester | Write E2E tests |
| 5 | Tester | Run all tests (typecheck + unit + E2E) |
| 6 | Builder | Fix any test failures |
| 7 | Reviewer | Review screenshots |
| 8 | Reviewer | Code review and refactoring |
| 9 | Builder | Git commit and tag |
| 10 | Lead | Report results, tear down team |

**Feedback loops:**
- Phase 2 fails → back to Phase 1 (max 3 iterations)
- Phase 5 fails → Phase 6 fixes → Phase 5 re-runs (max 5 iterations)
- Phase 7 issues → Phase 6 fixes → Phase 5 re-runs
- Phase 8 needs refactor → Phase 6 fixes → Phase 5 re-runs (max 3 iterations)

Each phase writes a JSON artifact to `progress/spec-NN/` and updates `manifest.json`. If context is lost mid-spec, re-running `/implement-spec NN` reads the manifest and resumes from the last completed phase.

---

## The IMPLEMENT.md Numbering Bug

`IMPLEMENT.md` lists specs numbered 01-15, but the mapping is wrong — it labels spec 02 as "Shared Types" when the actual file is `02-process-management.md`, and so on. The spec filenames in the `specs/` directory are the source of truth:

| IMPLEMENT.md says | Actual spec file |
|-------------------|-----------------|
| 01: Project Setup | `01-project-setup.md` |
| 02: Shared Types | `02-process-management.md` |
| 03: Shared Components | `03-shared-types.md` |
| ... | (shifted by one) |

This mismatch was caught during implementation by the agent's **MEMORY.md** system (see below). The agent recorded: *"IMPLEMENT.md labels don't match spec filenames: Always check actual spec file names"* — and from that point on, it always verified the actual filename before starting each spec. The `/implement-spec` skill itself uses the spec file path from the manifest, not the IMPLEMENT.md label, so the bug had no impact on the generated code.

---

## When Agent Teams Broke Down

The 15-spec build ran as a single continuous Claude Code session, compacting context between specs with `/compact`. Each spec spawned a fresh 3-agent team (builder, tester, reviewer). This worked — until it didn't.

### Quirky but Functional (Specs 01-08)

The 3-agent teams worked as designed, but the orchestrator had to learn workarounds for recurring misbehaviors:

- **Teammates acknowledging without executing** — A teammate would reply "Ready to proceed" instead of actually doing the work. The orchestrator learned to resend with "Execute it NOW"
- **Phase confusion** — The tester would re-execute Phase 4 (write E2E tests) when asked to do Phase 5 (run tests). Required explicit: "Phase 4 is already done. Execute Phase 5 NOW."
- **Reviewer going idle** — The reviewer would go idle before executing Phase 8 (code review), requiring the orchestrator to resend the instruction

These were annoyances, not blockers. Spec 05 needed 1 verify iteration (TS errors). Spec 08 needed 1 test_fix iteration (3 unused imports). Everything else passed clean.

### Message Delivery Breaks (Around Spec 09)

After repeated `/compact` cycles to manage the growing context window, the orchestrator hit a critical failure:

> *"Teammate messages not delivered in continued sessions: After context continuation, teammate messages may not be delivered."*

The persistent teammate agents were spawned fresh for each spec, but after compaction the orchestrator's messages to them became unreliable — it would send a phase instruction and get no response. The team framework was still functional, but the communication channel between the lead and its teammates had degraded.

### Self-Recovery via Task Agents

Rather than failing, the orchestrator adapted its strategy mid-build:

1. **Ran tests directly** — Instead of asking the tester to run Phase 5, the orchestrator executed typecheck/unit/E2E commands itself
2. **Switched to Task agents** — For review phases (7 and 8), it spawned fresh one-shot Task agents instead of relying on persistent teammates. Task agents don't depend on team message delivery — they receive their full context as a prompt parameter.
3. **Parallelized reviews** — When Phase 5 passed clean, it spawned Task agents for Phase 7 (screenshots) and Phase 8 (code review) simultaneously
4. **Full pivot** — By the later specs, the orchestrator had concluded: *"Task agents more reliable than teammates: For specs where teammates don't respond, skip straight to Task agents for all phases"*

The `progress/spec-NN/` artifacts are identical in structure regardless of whether a teammate or Task agent executed the phase — they only record outcomes. The result: specs 09-15 all achieved **0 fix iterations**, suggesting the adapted workflow was actually *more* reliable than the original.

---

## What is MEMORY.md?

Claude Code has a persistent memory system at `~/.claude/projects/<project>/memory/MEMORY.md`. This file survives across conversation sessions and context compactions. The agent reads it at the start of every conversation and updates it as it learns.

MEMORY.md is how the agent adapted its behavior over time without being explicitly told — including the team breakdown recovery described above. Every workaround, every pattern, every gotcha was recorded as it was discovered.

Here is the full MEMORY.md as it existed at the end of the build:

```markdown
# Memory - Lightning Wallet Demo Implementation

## Project: alby-oneshot-v6
Implementing 15 specs sequentially using `/implement-spec` skill with persistent agent teams.

## Progress
- Spec 01: done (project-setup) - commit 288675b, tag step-02
- Spec 02: done (process-management) - commit 9b94b0e, tag step-03
- Spec 03: done (shared-types) - commit 7f4de2c, tag step-04
- Spec 04: done (shared-components) - commit 513ff4c, tag step-05
- Spec 05: done (wallet-context) - commit 550cc9c, tag step-06, 1 verify iteration (TS errors + data-testid)
- Spec 06: done (layout) - commit 97a2ec9, tag step-07, 0 iterations (clean pass)
- Spec 07: done (scenario-1-simple-payment) - commit ce5371f, tag step-08, 0 iterations (clean pass)
- Spec 08: done (scenario-2-lightning-address) - commit 55fac13, tag step-09, 1 test_fix iteration (3 unused imports)
- Spec 09: done (scenario-3-notifications) - commit b9b5e2c, tag step-10, 0 iterations (clean pass)
- Spec 10: done (scenario-4-hold-invoice) - commit afd1164, tag step-11, 0 iterations (clean pass)
- Spec 11: done (scenario-5-proof-of-payment) - commit 45c9a8d, tag step-12, 0 iterations (clean pass)
- Spec 12: done (scenario-6-transaction-history) - commit 5e6e6a9, tag step-13, 0 iterations (clean pass)
- Spec 13: done (scenario-7-nostr-zap) - commit 9074fa9, tag step-14, 0 iterations (clean pass)
- Spec 14: done (scenario-8-fiat-conversion) - commit 8d317a7, tag step-15
- Spec 15: done (backend) - commit 5092ce6, tag step-16, 0 iterations (clean pass)
- Next: Spec 16 (testing-strategy) - FINAL SPEC

## Key Patterns
- **Teammates often acknowledge but don't execute**: Always resend with "Execute it NOW" if teammate just says "ready"
- **Post-commit manifest drift**: After Phase 9, manifest update creates uncommitted files. Commit with `chore: update spec NN manifest to done status`
- **IMPLEMENT.md labels don't match spec filenames**: Always check actual spec file names
- **Preamble tracking**: Send full PREAMBLE in first message to each teammate, reminder in subsequent
- **Phase 4/5 confusion**: Tester frequently resends Phase 4 instead of executing Phase 5. Always resend with explicit "Phase 4 is already done. Execute Phase 5 NOW."
- **Spec 03 uses @getalby/sdk**: Invoke `/alby-agent-skill` for specs using Lightning/NWC
- **Subpath exports confirmed**: `@getalby/lightning-tools/bolt11`, `/lnurl`, `/fiat` all work
- **Clean passes**: Specs 03 and 04 passed with 0 iterations; spec 05 needed 1 verify iteration
- **Reviewer idle on Phase 8**: Reviewer goes idle before executing Phase 8 code review. Always resend.
- **Teammate messages not delivered in continued sessions**: After context continuation, teammate messages may not be delivered. Run tests yourself and use Task agents as fallback for review phases.
- **Parallel Phase 7+8**: When Phase 5 passes clean, spawn Task agents for Phase 7 and 8 in parallel to save time.

## Spec-Specific Notes
- Specs 01-02: No code exports (config/scripts only)
- Spec 03: Single file `src/types/index.ts`, 10 unit tests
- Spec 04: 8 files (7 components + index.ts), 38 unit tests, Tailwind bitcoin color already in config
- Spec 05: 13 files (context + 8 hooks + 3 wallet components), 149 unit tests + 1 E2E, Card.tsx modified for data-testid prop
- Spec 06: 15 files (layout + sidebar + scenario page + transaction log + 8 placeholder pages), 66 unit tests + 6 E2E, total project: 215 unit + 7 E2E
- Spec 07: 5 files (4 components + modified index), 53 unit tests + 9 E2E, total project: 268 unit + 27 E2E (9x3 browsers), builder also created test files in Phase 1
- Spec 08: 4 new files + 2 modified + 2 test files, 38 unit tests + 9 E2E, total project: 306 unit + 36 E2E, builder created test files in Phase 1 again
- Spec 09: 5 new files + 2 modified + 2 test files, 47 unit tests + 9 E2E, total project: 353 unit + 45 E2E, clean pass (0 iterations)
- Spec 10: 7 new files + 2 modified + 3 test files, 84 unit tests + 10 E2E, total project: 436 unit + 55 E2E, clean pass (0 iterations), new src/lib/crypto.ts
- Spec 11: 3 new files + 1 modified + 2 test files, 48 unit tests + 10 E2E, total project: 484 unit + 65 E2E, clean pass (0 iterations)
- Spec 12: 3 new files + 1 new hook + 2 modified + test files, 89 unit tests + 10 E2E, total project: 573 unit + 75 E2E, clean pass (0 iterations)
- Spec 13: 4 new files + 1 new hook + 2 modified + test files, 43 unit tests + 10 E2E, total project: 616 unit + 85 E2E, clean pass (0 iterations)
- Spec 14: Fiat conversion scenario page, total project: ~660 unit + 85 E2E
- Spec 15: 3 server files (config + index + routes/demo) + 1 test file, 4 unit tests + 0 E2E (backend-only), total project: 662 unit + 85 E2E, clean pass, npm installed supertest + @types/supertest
- **Backend specs skip E2E/screenshots**: No UI page means Phase 4 (E2E) and Phase 7 (screenshots) are trivially passed
- **Task agents more reliable than teammates**: For specs where teammates don't respond, skip straight to Task agents for all phases
```

---

## The Alby Agent Skill

The `.claude/skills/alby-agent-skill/` directory provides Claude Code with authoritative documentation for Bitcoin Lightning integration. When invoked with `/alby-agent-skill`, it loads:

- **NWC Client docs** — `@getalby/sdk` API for wallet operations (pay, invoice, balance, notifications, hold invoices)
- **Lightning Tools docs** — `@getalby/lightning-tools` for BOLT-11 parsing, LNURL, fiat conversion
- **Bitcoin Connect docs** — UI components for wallet connection
- **TypeScript definitions** — Complete `.d.ts` files for type-safe implementation
- **Testing patterns** — Mock factories, test wallet setup

This skill was used in two places:
1. **During spec alignment** — to verify that SDK method signatures in the specs matched the actual library API
2. **During implementation** — specs that use Lightning features (03+) trigger `/alby-agent-skill` to give the builder agent accurate API knowledge

Without this skill, the agent would have had to guess at SDK method signatures or make web requests for documentation. The skill provides offline, version-pinned docs that match the exact library versions in `package.json`.

---

## The Generated Application

### Architecture

```
┌─────────────────────────────────────────────────────┐
│                    React App (:5741)                  │
├──────────────┬──────────────────────────────────────┤
│   Sidebar    │         Scenario Page                 │
│              │  ┌─────────────────────────────────┐ │
│  Scenario 1  │  │  Alice's Wallet    Bob's Wallet │ │
│  Scenario 2  │  │  ┌───────────┐    ┌───────────┐ │ │
│  Scenario 3  │  │  │  Balance  │    │  Balance  │ │ │
│  ...         │  │  │  Actions  │    │  Actions  │ │ │
│  Scenario 8  │  │  └───────────┘    └───────────┘ │ │
│              │  │  Transaction Log / Status       │ │
│              │  └─────────────────────────────────┘ │
├──────────────┴──────────────────────────────────────┤
│              Express API (:3741)                      │
└─────────────────────────────────────────────────────┘
│                                                       │
│          Nostr Wallet Connect (NIP-47)                │
│              ↕ WebSocket relay ↕                      │
│          Lightning Network (testnet)                  │
└───────────────────────────────────────────────────────┘
```

Two wallets (Alice and Bob) connect via NWC URLs from [faucet.nwc.dev](https://faucet.nwc.dev). All communication with the Lightning Network goes through Nostr relays using the NIP-47 protocol — no direct node access required.

### The 8 Scenarios

| # | Scenario | What it demonstrates |
|---|----------|---------------------|
| 1 | **Simple Payment** | Bob creates a BOLT-11 invoice, Alice pays it. The fundamental Lightning flow. |
| 2 | **Lightning Address** | Alice pays `bob@domain.com` — system resolves LNURL, fetches invoice, pays automatically. |
| 3 | **Notifications** | Bob subscribes to real-time payment notifications. Alice sends payments, Bob's UI updates live. |
| 4 | **Hold Invoice** | Escrow-style payment: Alice pays, funds are held until Bob settles (claims) or cancels (refunds). |
| 5 | **Proof of Payment** | Alice pays and gets a preimage. Demonstrates `hash(preimage) === payment_hash` verification. |
| 6 | **Transaction History** | Both wallets query and display their past transactions with filtering. |
| 7 | **Nostr Zap** | Alice "zaps" Bob's Nostr note — social tipping with proper Nostr event tags. |
| 8 | **Fiat Conversion** | Display amounts in both sats and fiat (USD, EUR, GBP). Real-time conversion as you type. |

### Tech Stack

| Layer | Technology |
|-------|-----------|
| Frontend | React 18 + TypeScript 5.6 + Vite 6 |
| Styling | Tailwind CSS 3.4 |
| State | React Context + useReducer |
| Routing | React Router DOM 7 |
| Lightning | @getalby/sdk 7.0 (NWC) + @getalby/lightning-tools 6.1 |
| Backend | Express 4.21 |
| Unit Tests | Vitest 2.1 + Testing Library |
| E2E Tests | Playwright 1.48 (Chromium, Firefox, Mobile Safari) |

### Project Structure

```
src/
├── main.tsx                         # Entry point
├── App.tsx                          # Router with lazy-loaded pages
├── index.css                        # Tailwind + custom components
│
├── types/index.ts                   # ~250 types, constants, type guards
├── lib/crypto.ts                    # Preimage/hash crypto utilities
│
├── context/WalletContext.tsx         # Dual-wallet state (Alice & Bob)
│
├── hooks/                           # 14 custom hooks
│   ├── useWallet.ts                 #   Get wallet state
│   ├── useWalletActions.ts          #   Connect/disconnect
│   ├── useNWCClient.ts              #   Raw NWC client access
│   ├── useBalance.ts                #   Balance polling
│   ├── useInvoice.ts                #   Create invoices
│   ├── usePayment.ts                #   Pay invoices
│   ├── useBudget.ts                 #   Spending budget
│   ├── useFiatRate.ts               #   BTC/fiat rates
│   ├── useTransactionLog.ts         #   Event log management
│   ├── useLightningAddressPayment.ts #  Pay Lightning addresses
│   ├── useNotifications.ts          #   NWC notification subscriptions
│   ├── useHoldInvoice.ts            #   Hold invoice lifecycle
│   ├── useTransactions.ts           #   Transaction history
│   └── useZap.ts                    #   Nostr zap functionality
│
├── components/
│   ├── ui/                          # Shared primitives
│   │   ├── Button.tsx               #   4 variants, 3 sizes
│   │   ├── Input.tsx                #   With forwardRef
│   │   ├── Card.tsx                 #   Container with shadow
│   │   ├── Badge.tsx                #   Status indicators
│   │   ├── Spinner.tsx              #   Loading animation
│   │   ├── QRCode.tsx               #   QR code display
│   │   └── CopyButton.tsx           #   Copy-to-clipboard
│   ├── wallet/                      # Wallet display components
│   │   ├── WalletCard.tsx
│   │   ├── BalanceDisplay.tsx
│   │   └── WalletConnect.tsx
│   ├── layout/                      # App shell
│   │   ├── Layout.tsx
│   │   ├── Sidebar.tsx
│   │   └── ScenarioPage.tsx
│   └── transaction/
│       └── TransactionLog.tsx
│
├── pages/                           # 8 scenario pages
│   ├── 1-SimplePayment/
│   ├── 2-LightningAddress/
│   ├── 3-Notifications/
│   ├── 4-HoldInvoice/
│   ├── 5-ProofOfPayment/
│   ├── 6-TransactionHistory/
│   ├── 7-NostrZap/
│   └── 8-FiatConversion/

server/
├── index.ts                         # Express app + middleware
├── config.ts                        # Environment config
└── routes/demo.ts                   # Demo wallet endpoints

tests/
├── setup.ts                         # Global mocks (crypto, WebSocket)
├── unit/                            # 662+ unit tests
├── e2e/                             # 85 E2E tests (3 browsers)
├── mocks/                           # NWC, Lightning Tools, crypto mocks
└── utils/                           # Test wallet helpers

progress/                            # Implementation tracking
├── spec-01/ through spec-15/       # Phase artifacts + manifests
```

---

## Running the Application

### Prerequisites

- Node.js 18+
- npm

### Install

```bash
npm install
```

### Development

```bash
npm run dev
```

This starts both:
- **Frontend** (Vite) at `http://localhost:5741`
- **Backend** (Express) at `http://localhost:3741`

### Connect Wallets

1. Go to [faucet.nwc.dev](https://faucet.nwc.dev) and create two test wallets
2. Copy the NWC connection strings
3. Paste them into the Alice and Bob wallet connection inputs in the app
4. Start exploring the 8 scenarios

### Other Commands

| Command | Purpose |
|---------|---------|
| `npm run dev:client` | Frontend only |
| `npm run dev:server` | Backend only |
| `npm run build` | TypeScript check + Vite production build |
| `npm run preview` | Preview the production build |
| `npm run typecheck` | TypeScript type checking |
| `npm run lint` | ESLint |

---

## Testing

```bash
# Unit tests (662+ tests)
npm test

# Unit tests with UI dashboard
npm run test:ui

# Coverage report
npm run test:coverage

# E2E tests — requires dev server running
npm run dev &
npm run test:e2e
```

E2E tests run across 3 browsers: Chromium, Firefox, and Mobile Safari (iPhone 13 emulation).

**Test structure:**
- Unit tests: `tests/unit/**/*.test.{ts,tsx}`
- E2E tests: `tests/e2e/**/*.spec.ts`
- Coverage thresholds: 80% statements, 75% branches, 80% functions, 80% lines

---

## Build Pipeline Summary

The complete pipeline from zero to working application:

```
PRD.md (manual)
  ↓
specs/00-16 (generated from PRD)
  ↓
ALIGNMENT_TRACKER.md ← ALIGN_SPEC_PROMPT.md (cross-spec consistency)
  ↓
/implement-spec init → specs/PREAMBLE.md (agent context document)
  ↓
@IMPLEMENT.md → /implement-spec 01..15
  ↓
  For each spec:
    Phase 1: Builder implements code
    Phase 2: Reviewer verifies
    Phase 3: Tester writes unit tests
    Phase 4: Tester writes E2E tests
    Phase 5: Run all tests
    Phase 6: Fix failures (loop)
    Phase 7: Screenshot review
    Phase 8: Code review
    Phase 9: Git commit + tag
    Phase 10: Teardown + report
  ↓
662 unit tests + 85 E2E tests passing
35 git commits, 16 tags (START-HERE + step-02 through step-16)
```

**Total: 15 specs, 3-agent teams, 10 phases each, ~100 files of application code.**
