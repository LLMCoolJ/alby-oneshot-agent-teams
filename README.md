# Lightning Wallet Demo

A React application demonstrating 8 Bitcoin Lightning Network payment scenarios using the [Alby SDK](https://github.com/getAlby/alby-js-sdk). Built entirely by Claude Code agent teams following a spec-driven workflow.

**Live demo wallets:** [faucet.nwc.dev](https://faucet.nwc.dev) (no setup required)

## Prerequisites: Claude Code Sandbox Setup

This project was built using Claude Code's `/sandbox` command, which creates an isolated workspace with filesystem and network sandboxing. The sandbox allows Claude Code to run commands freely within the project directory while preventing unintended side effects outside of it.

**Before cloning and rebuilding, you need to configure `CLAUDE_CODE_TMPDIR` to point to your project directory.** This variable tells Claude Code where agent teams are allowed to write temporary files, artifacts, and progress tracking data. Without it, agent workers will fail with permission errors.

### 1. Update `.claude/settings.json` and `.claude/settings.local.json`

Both files contain a hardcoded `CLAUDE_CODE_TMPDIR`. After cloning, replace it with your actual project path:

```jsonc
// .claude/settings.json and .claude/settings.local.json
{
  "CLAUDE_CODE_TMPDIR": "/path/to/your/clone",
  "env": {
    "CLAUDE_CODE_TMPDIR": "/path/to/your/clone",
    // ...
  }
}
```

### 2. Optionally set in your shell profile

If you want the variable available globally (useful if you work across multiple terminals):

```bash
# ~/.bashrc or ~/.zshrc
export CLAUDE_CODE_TMPDIR="/path/to/your/clone"
```

### 3. Enable agent teams

The settings files also include `CLAUDE_CODE_EXPERIMENTAL_AGENT_TEAMS: true`, which is required for the multi-agent `/implement-spec` workflow. This is already set in the checked-in config — just make sure you don't remove it.

---

## Table of Contents

- [Prerequisites: Claude Code Sandbox Setup](#prerequisites-claude-code-sandbox-setup)
- [How This Repo Was Built](#how-this-repo-was-built)
  - [Starting Point](#starting-point)
  - [Step 1: Write the PRD](#step-1-write-the-prd)
  - [Step 2: Generate Specs from the PRD](#step-2-generate-specs-from-the-prd)
  - [Step 3: Align Specs with ALIGN_SPEC_PROMPT.md](#step-3-align-specs-with-align_spec_promptmd)
  - [Step 4: Generate PREAMBLE.md](#step-4-generate-preamblemd)
  - [Step 5: Implement All Specs](#step-5-implement-all-specs)
- [The IMPLEMENT.md Numbering Bug](#the-implementmd-numbering-bug)
- [What is MEMORY.md?](#what-is-memorymd)
- [The Alby Agent Skill](#the-alby-agent-skill)
- [The Generated Application](#the-generated-application)
  - [Architecture](#architecture)
  - [The 8 Scenarios](#the-8-scenarios)
  - [Tech Stack](#tech-stack)
  - [Project Structure](#project-structure)
- [Running the Application](#running-the-application)
- [Testing](#testing)
- [Build Pipeline Summary](#build-pipeline-summary)

---

## How This Repo Was Built

This entire application was generated by Claude Code using a multi-phase workflow. The repo includes a `START-HERE` git tag that marks the starting point — everything before it is scaffolding (the specs, skills, and prompts); everything after it is generated code.

### Starting Point

Checkout `START-HERE` to see what existed before any code was generated:

```bash
git checkout START-HERE
```

At this point the repo contained:

- `PRD.md` — the product requirements document
- `specs/` — 17 specification files (00-overview through 16-testing-strategy)
- `specs/ALIGNMENT_TRACKER.md` — tracking cross-spec consistency
- `ALIGN_SPEC_PROMPT.md` — the prompt used to align specs
- `IMPLEMENT.md` — the orchestration prompt for implementing all specs
- `.claude/skills/implement-spec/` — the skill definition for implementing a single spec
- `.claude/skills/alby-agent-skill/` — Lightning/NWC documentation skill
- `progress/` — empty manifest directories for tracking implementation phases

No application code existed yet. The 35 commits after `START-HERE` are all generated.

### Step 1: Write the PRD

The process starts with `PRD.md`, a product requirements document describing:

- 8 "Alice & Bob" Lightning payment scenarios
- The tech stack (React, TypeScript, Vite, Tailwind, Express, Alby SDK)
- UI component descriptions (sidebar, wallet cards, transaction log)
- SDK method signatures for each scenario
- Testnet setup instructions

The PRD was written manually to define what the application should do.

### Step 2: Generate Specs from the PRD

The PRD was broken into 17 implementation specs in the `specs/` directory:

| # | Spec | Purpose |
|---|------|---------|
| 00 | overview | Architecture reference (no code) |
| 01 | project-setup | Vite, TypeScript, Tailwind config |
| 02 | process-management | Systemd services, dev scripts |
| 03 | shared-types | TypeScript types, constants, type guards |
| 04 | shared-components | UI primitives (Button, Card, Badge, etc.) |
| 05 | wallet-context | React Context, hooks, wallet components |
| 06 | layout | App shell, sidebar, routing |
| 07-14 | scenarios 1-8 | Each payment scenario page |
| 15 | backend | Express API server |
| 16 | testing-strategy | Test infrastructure, mocks, CI |

Each spec defines exactly what files to create, what they export, what tests to write, and what dependencies they have on earlier specs. Specs are ordered so each one only imports from specs with a lower number.

### Step 3: Align Specs with ALIGN_SPEC_PROMPT.md

Before implementation, specs were cross-checked for consistency using `ALIGN_SPEC_PROMPT.md`. This prompt:

1. Reads all reference specs (types, components, hooks, layout, backend)
2. Reads the target scenario spec
3. Checks for inconsistencies: type names, component props, hook signatures, route paths, file structure patterns
4. Fixes inconsistencies (preferring to fix the scenario spec over the reference)
5. Tracks progress in `specs/ALIGNMENT_TRACKER.md`

The alignment prompt is run repeatedly. Each run processes one spec, updating its status from `pending` → `fixing` → `no fixes`. The process uses the `/alby-agent-skill` to verify SDK method signatures are correct.

**To re-run alignment:**

1. Set any spec status to `pending` in `specs/ALIGNMENT_TRACKER.md`
2. Run the prompt from `ALIGN_SPEC_PROMPT.md` in Claude Code
3. Repeat until all specs show `no fixes`

### Step 4: Generate PREAMBLE.md

Before implementation can begin, the system needs a context document that summarizes all specs for the agent workers. This is generated with:

```
/implement-spec init
```

This spawns parallel sub-agents (one per spec) that extract structured data: file lists, exports, routes, coding standards, mock patterns, and test commands. The results are merged into `specs/PREAMBLE.md`, which contains:

- Tech stack summary
- Reference file tables (what each spec creates)
- Scenario route tables
- Import availability rules (spec N can only import from specs < N)
- 43 coding standards extracted from all specs
- Test command reference
- Mock patterns for NWC, Lightning Tools, and hooks

Every agent worker receives PREAMBLE.md as its first context, ensuring consistent implementation across all specs.

### Step 5: Implement All Specs

Implementation is orchestrated by `IMPLEMENT.md`, which runs `/implement-spec NN` for each spec in sequence. Each spec goes through a 10-phase workflow managed by a 3-agent team:

| Phase | Agent | Task |
|-------|-------|------|
| 1 | Builder | Implement the spec's code |
| 2 | Reviewer | Verify implementation matches spec |
| 3 | Tester | Write unit tests |
| 4 | Tester | Write E2E tests |
| 5 | Tester | Run all tests (typecheck + unit + E2E) |
| 6 | Builder | Fix any test failures |
| 7 | Reviewer | Review screenshots |
| 8 | Reviewer | Code review and refactoring |
| 9 | Builder | Git commit and tag |
| 10 | Lead | Report results, tear down team |

**Feedback loops:**
- Phase 2 fails → back to Phase 1 (max 3 iterations)
- Phase 5 fails → Phase 6 fixes → Phase 5 re-runs (max 5 iterations)
- Phase 7 issues → Phase 6 fixes → Phase 5 re-runs
- Phase 8 needs refactor → Phase 6 fixes → Phase 5 re-runs (max 3 iterations)

Each phase writes a JSON artifact to `progress/spec-NN/` and updates `manifest.json`. If context is lost mid-spec, re-running `/implement-spec NN` reads the manifest and resumes from the last completed phase.

**To rebuild from scratch:**

```bash
git checkout START-HERE
```

Then tell Claude Code:

```
@IMPLEMENT.md
```

This triggers the full sequential build of all 15 specs.

---

## The IMPLEMENT.md Numbering Bug

`IMPLEMENT.md` lists specs numbered 01-15, but the mapping is wrong — it labels spec 02 as "Shared Types" when the actual file is `02-process-management.md`, and so on. The spec filenames in the `specs/` directory are the source of truth:

| IMPLEMENT.md says | Actual spec file |
|-------------------|-----------------|
| 01: Project Setup | `01-project-setup.md` |
| 02: Shared Types | `02-process-management.md` |
| 03: Shared Components | `03-shared-types.md` |
| ... | (shifted by one) |

This mismatch was caught during implementation by the agent's **MEMORY.md** system (see below). The agent recorded: *"IMPLEMENT.md labels don't match spec filenames: Always check actual spec file names"* — and from that point on, it always verified the actual filename before starting each spec. The `/implement-spec` skill itself uses the spec file path from the manifest, not the IMPLEMENT.md label, so the bug had no impact on the generated code.

---

## What is MEMORY.md?

Claude Code has a persistent memory system at `~/.claude/projects/<project>/memory/MEMORY.md`. This file survives across conversation sessions and context compactions. The agent reads it at the start of every conversation and updates it as it learns.

During the 15-spec build, the agent team recorded:

**Progress tracking** — which specs were done, their commit hashes, and how many fix iterations each required:
```
- Spec 07: done (scenario-1-simple-payment) - commit ce5371f, 0 iterations (clean pass)
- Spec 08: done (scenario-2-lightning-address) - commit 55fac13, 1 test_fix iteration (3 unused imports)
```

**Behavioral patterns** — things that went wrong and how to handle them:
```
- Teammates often acknowledge but don't execute: Always resend with "Execute it NOW"
- Phase 4/5 confusion: Tester frequently resends Phase 4 instead of Phase 5
- Reviewer idle on Phase 8: Reviewer goes idle before executing code review. Always resend.
- Task agents more reliable than teammates for fallback
```

**Spec-specific notes** — file counts, test counts, gotchas:
```
- Spec 10: 7 new files, 84 unit tests + 10 E2E, new src/lib/crypto.ts
- Backend specs skip E2E/screenshots: No UI page means Phase 4 and Phase 7 are trivially passed
```

MEMORY.md is how the agent adapts its behavior over time without being explicitly told. By spec 09, the agent had learned to run Phase 7 and Phase 8 in parallel when Phase 5 passed cleanly, and to fall back to Task agents when teammates stopped responding.

---

## The Alby Agent Skill

The `.claude/skills/alby-agent-skill/` directory provides Claude Code with authoritative documentation for Bitcoin Lightning integration. When invoked with `/alby-agent-skill`, it loads:

- **NWC Client docs** — `@getalby/sdk` API for wallet operations (pay, invoice, balance, notifications, hold invoices)
- **Lightning Tools docs** — `@getalby/lightning-tools` for BOLT-11 parsing, LNURL, fiat conversion
- **Bitcoin Connect docs** — UI components for wallet connection
- **TypeScript definitions** — Complete `.d.ts` files for type-safe implementation
- **Testing patterns** — Mock factories, test wallet setup

This skill was used in two places:
1. **During spec alignment** — to verify that SDK method signatures in the specs matched the actual library API
2. **During implementation** — specs that use Lightning features (03+) trigger `/alby-agent-skill` to give the builder agent accurate API knowledge

Without this skill, the agent would have had to guess at SDK method signatures or make web requests for documentation. The skill provides offline, version-pinned docs that match the exact library versions in `package.json`.

---

## The Generated Application

### Architecture

```
┌─────────────────────────────────────────────────────┐
│                    React App (:5741)                  │
├──────────────┬──────────────────────────────────────┤
│   Sidebar    │         Scenario Page                 │
│              │  ┌─────────────────────────────────┐ │
│  Scenario 1  │  │  Alice's Wallet    Bob's Wallet │ │
│  Scenario 2  │  │  ┌───────────┐    ┌───────────┐ │ │
│  Scenario 3  │  │  │  Balance  │    │  Balance  │ │ │
│  ...         │  │  │  Actions  │    │  Actions  │ │ │
│  Scenario 8  │  │  └───────────┘    └───────────┘ │ │
│              │  │  Transaction Log / Status       │ │
│              │  └─────────────────────────────────┘ │
├──────────────┴──────────────────────────────────────┤
│              Express API (:3741)                      │
└─────────────────────────────────────────────────────┘
│                                                       │
│          Nostr Wallet Connect (NIP-47)                │
│              ↕ WebSocket relay ↕                      │
│          Lightning Network (testnet)                  │
└───────────────────────────────────────────────────────┘
```

Two wallets (Alice and Bob) connect via NWC URLs from [faucet.nwc.dev](https://faucet.nwc.dev). All communication with the Lightning Network goes through Nostr relays using the NIP-47 protocol — no direct node access required.

### The 8 Scenarios

| # | Scenario | What it demonstrates |
|---|----------|---------------------|
| 1 | **Simple Payment** | Bob creates a BOLT-11 invoice, Alice pays it. The fundamental Lightning flow. |
| 2 | **Lightning Address** | Alice pays `bob@domain.com` — system resolves LNURL, fetches invoice, pays automatically. |
| 3 | **Notifications** | Bob subscribes to real-time payment notifications. Alice sends payments, Bob's UI updates live. |
| 4 | **Hold Invoice** | Escrow-style payment: Alice pays, funds are held until Bob settles (claims) or cancels (refunds). |
| 5 | **Proof of Payment** | Alice pays and gets a preimage. Demonstrates `hash(preimage) === payment_hash` verification. |
| 6 | **Transaction History** | Both wallets query and display their past transactions with filtering. |
| 7 | **Nostr Zap** | Alice "zaps" Bob's Nostr note — social tipping with proper Nostr event tags. |
| 8 | **Fiat Conversion** | Display amounts in both sats and fiat (USD, EUR, GBP). Real-time conversion as you type. |

### Tech Stack

| Layer | Technology |
|-------|-----------|
| Frontend | React 18 + TypeScript 5.6 + Vite 6 |
| Styling | Tailwind CSS 3.4 |
| State | React Context + useReducer |
| Routing | React Router DOM 7 |
| Lightning | @getalby/sdk 7.0 (NWC) + @getalby/lightning-tools 6.1 |
| Backend | Express 4.21 |
| Unit Tests | Vitest 2.1 + Testing Library |
| E2E Tests | Playwright 1.48 (Chromium, Firefox, Mobile Safari) |

### Project Structure

```
src/
├── main.tsx                         # Entry point
├── App.tsx                          # Router with lazy-loaded pages
├── index.css                        # Tailwind + custom components
│
├── types/index.ts                   # ~250 types, constants, type guards
├── lib/crypto.ts                    # Preimage/hash crypto utilities
│
├── context/WalletContext.tsx         # Dual-wallet state (Alice & Bob)
│
├── hooks/                           # 14 custom hooks
│   ├── useWallet.ts                 #   Get wallet state
│   ├── useWalletActions.ts          #   Connect/disconnect
│   ├── useNWCClient.ts              #   Raw NWC client access
│   ├── useBalance.ts                #   Balance polling
│   ├── useInvoice.ts                #   Create invoices
│   ├── usePayment.ts                #   Pay invoices
│   ├── useBudget.ts                 #   Spending budget
│   ├── useFiatRate.ts               #   BTC/fiat rates
│   ├── useTransactionLog.ts         #   Event log management
│   ├── useLightningAddressPayment.ts #  Pay Lightning addresses
│   ├── useNotifications.ts          #   NWC notification subscriptions
│   ├── useHoldInvoice.ts            #   Hold invoice lifecycle
│   ├── useTransactions.ts           #   Transaction history
│   └── useZap.ts                    #   Nostr zap functionality
│
├── components/
│   ├── ui/                          # Shared primitives
│   │   ├── Button.tsx               #   4 variants, 3 sizes
│   │   ├── Input.tsx                #   With forwardRef
│   │   ├── Card.tsx                 #   Container with shadow
│   │   ├── Badge.tsx                #   Status indicators
│   │   ├── Spinner.tsx              #   Loading animation
│   │   ├── QRCode.tsx               #   QR code display
│   │   └── CopyButton.tsx           #   Copy-to-clipboard
│   ├── wallet/                      # Wallet display components
│   │   ├── WalletCard.tsx
│   │   ├── BalanceDisplay.tsx
│   │   └── WalletConnect.tsx
│   ├── layout/                      # App shell
│   │   ├── Layout.tsx
│   │   ├── Sidebar.tsx
│   │   └── ScenarioPage.tsx
│   └── transaction/
│       └── TransactionLog.tsx
│
├── pages/                           # 8 scenario pages
│   ├── 1-SimplePayment/
│   ├── 2-LightningAddress/
│   ├── 3-Notifications/
│   ├── 4-HoldInvoice/
│   ├── 5-ProofOfPayment/
│   ├── 6-TransactionHistory/
│   ├── 7-NostrZap/
│   └── 8-FiatConversion/

server/
├── index.ts                         # Express app + middleware
├── config.ts                        # Environment config
└── routes/demo.ts                   # Demo wallet endpoints

tests/
├── setup.ts                         # Global mocks (crypto, WebSocket)
├── unit/                            # 662+ unit tests
├── e2e/                             # 85 E2E tests (3 browsers)
├── mocks/                           # NWC, Lightning Tools, crypto mocks
└── utils/                           # Test wallet helpers

progress/                            # Implementation tracking
├── spec-01/ through spec-15/       # Phase artifacts + manifests
```

---

## Running the Application

### Prerequisites

- Node.js 18+
- npm

### Install

```bash
npm install
```

### Development

```bash
npm run dev
```

This starts both:
- **Frontend** (Vite) at `http://localhost:5741`
- **Backend** (Express) at `http://localhost:3741`

### Connect Wallets

1. Go to [faucet.nwc.dev](https://faucet.nwc.dev) and create two test wallets
2. Copy the NWC connection strings
3. Paste them into the Alice and Bob wallet connection inputs in the app
4. Start exploring the 8 scenarios

### Other Commands

| Command | Purpose |
|---------|---------|
| `npm run dev:client` | Frontend only |
| `npm run dev:server` | Backend only |
| `npm run build` | TypeScript check + Vite production build |
| `npm run preview` | Preview the production build |
| `npm run typecheck` | TypeScript type checking |
| `npm run lint` | ESLint |

---

## Testing

```bash
# Unit tests (662+ tests)
npm test

# Unit tests with UI dashboard
npm run test:ui

# Coverage report
npm run test:coverage

# E2E tests — requires dev server running
npm run dev &
npm run test:e2e
```

E2E tests run across 3 browsers: Chromium, Firefox, and Mobile Safari (iPhone 13 emulation).

**Test structure:**
- Unit tests: `tests/unit/**/*.test.{ts,tsx}`
- E2E tests: `tests/e2e/**/*.spec.ts`
- Coverage thresholds: 80% statements, 75% branches, 80% functions, 80% lines

---

## Build Pipeline Summary

The complete pipeline from zero to working application:

```
PRD.md (manual)
  ↓
specs/00-16 (generated from PRD)
  ↓
ALIGNMENT_TRACKER.md ← ALIGN_SPEC_PROMPT.md (cross-spec consistency)
  ↓
/implement-spec init → specs/PREAMBLE.md (agent context document)
  ↓
@IMPLEMENT.md → /implement-spec 01..15
  ↓
  For each spec:
    Phase 1: Builder implements code
    Phase 2: Reviewer verifies
    Phase 3: Tester writes unit tests
    Phase 4: Tester writes E2E tests
    Phase 5: Run all tests
    Phase 6: Fix failures (loop)
    Phase 7: Screenshot review
    Phase 8: Code review
    Phase 9: Git commit + tag
    Phase 10: Teardown + report
  ↓
662 unit tests + 85 E2E tests passing
35 git commits, 16 tags (START-HERE + step-02 through step-16)
```

**Total: 15 specs, 3-agent teams, 10 phases each, ~100 files of application code.**
